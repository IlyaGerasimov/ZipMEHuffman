\documentclass{article}
\usepackage{graphicx}
\usepackage[russian]{babel}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts}

\title{Задание 3}
\author{И. Герасимов}
\date{}
\begin{document}
\maketitle

\section{Использование программы}

\begin{verbatim}
python3.8 main.py -f file[.zmh]
\end{verbatim}

Если расширение не совпадает с <<.zmh>>, реализуется первый режим (кодирование).

Если расширение совпадает с <<.zmh>>, реализуется второй режим (декодирование).

\section{Формат файла .zmh}

Описание идет по порядку следования байтов в тексте:

\begin{itemize}
\item 1 байт - количество кодируемых символов (от 1 до 255). Обозначим это значение $n$;
\item 1 байт - минимальное количество байт, необходимых, чтобы уместить самый длиный код символа (например, самая большая длина кода символа равна 14 битам. Тогда будет записано \\x02, то есть не менее 2 байта). Обозначим это значение $l_{max}$;
\item $n\cdot(1 + l_{max} + 1)$ байт - таблица кодирования символов. Для каждой из $n$ записей первый байт указывает символ. Следующие $l_{max}$ байт указывают код символа. И 1 байт указывает длину кодирования символа.
\item Далее идет код бинарного файла.
\item В конце 1 байт отводится на то, сколько в последнем байте кода файла значащих битов. Это связано с тем, что мы могли получить длину кода сообщения, не кратную 8. Догда дополняем нулями, но указываем сколько добавили, чтобы при декодировании их убрать.
\end{itemize}

Стоит отметить, что дополнение нулями для кратности производится слева (например, если остался бит <<1>>, то последний байт кода сообщения выглядит как <<00000001>>).




\end{document}	